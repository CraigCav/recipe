{"pageProps":{"frontmatter":{"path":"/guides/principles","title":"Principles","order":20},"code":"var Component=(()=>{var c=Object.create;var a=Object.defineProperty;var h=Object.getOwnPropertyDescriptor;var d=Object.getOwnPropertyNames;var p=Object.getPrototypeOf,u=Object.prototype.hasOwnProperty;var r=i=>a(i,\"__esModule\",{value:!0});var m=(i,e)=>()=>(e||i((e={exports:{}}).exports,e),e.exports),g=(i,e)=>{r(i);for(var t in e)a(i,t,{get:e[t],enumerable:!0})},f=(i,e,t)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let o of d(e))!u.call(i,o)&&o!==\"default\"&&a(i,o,{get:()=>e[o],enumerable:!(t=h(e,o))||t.enumerable});return i},y=i=>f(r(a(i!=null?c(p(i)):{},\"default\",i&&i.__esModule&&\"default\"in i?{get:()=>i.default,enumerable:!0}:{value:i,enumerable:!0})),i);var l=m((I,s)=>{s.exports=_jsx_runtime});var k={};g(k,{default:()=>v,frontmatter:()=>b});var n=y(l()),b={path:\"/guides/principles\",title:\"Principles\",order:20};function w(i){let e=Object.assign({p:\"p\",hr:\"hr\",h2:\"h2\",h3:\"h3\",code:\"code\",ul:\"ul\",li:\"li\",a:\"a\"},i.components),{wrapper:t}=e,o=(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.p,{children:\"Principles are the standards that guide decision making. Recipe's core values help decisions move in a consistent direction.\"}),`\n`,(0,n.jsx)(e.hr,{}),`\n`,(0,n.jsx)(e.h2,{id:\"using-recipe\",children:\"Using Recipe\"}),`\n`,(0,n.jsx)(e.h3,{id:\"freedom-through-limitation\",children:\"Freedom through limitation\"}),`\n`,(0,n.jsx)(e.p,{children:\"Existing component libraries (like Semantic or Bootstrap, etc.) provide a huge variety of options for designers and developers to use. By contrast, Recipe restricts the number of options available to allow more polished interfaces to be designed and provide designers and developers the freedom to focus on solving user problems, instead of spending time making a decision about which component to use.\"}),`\n`,(0,n.jsx)(e.h3,{id:\"containers-are-responsible-for-layout\",children:\"Containers are responsible for layout\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"We consider properties such as \",(0,n.jsx)(e.code,{children:\"margin\"}),\" and \",(0,n.jsx)(e.code,{children:\"position\"}),\" to be aspects of layout. Individual components should not have opinions about layout outside of their own border. Instead layout is contextually applied by containers to their children.\"]}),`\n`,(0,n.jsx)(e.h3,{id:\"progressive-enhancement\",children:\"Progressive enhancement\"}),`\n`,(0,n.jsx)(e.p,{children:\"Design layouts with a mobile first approach. Use responsive design to enhance layouts to make better use of the space available on larger devices.\"}),`\n`,(0,n.jsx)(e.hr,{}),`\n`,(0,n.jsx)(e.h2,{id:\"contributing-to-recipe\",children:\"Contributing to Recipe\"}),`\n`,(0,n.jsx)(e.h3,{id:\"consistency-over-flexibility\",children:\"Consistency over flexibility\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"We're used to favoring flexibility. If a component is flexible, there will be more ways others can use it in the future, right? But flexibility works in opposition to consistency. Flexibility is an opportunity for downstream applications to do something unexpected, putting a cognitive burden on the end user.\"}),`\n`,(0,n.jsx)(e.li,{children:\"Flexibility is a one way door. If you ship an overly flexible component, it's hard to roll back once adopted by downstream applications.\"}),`\n`,(0,n.jsx)(e.li,{children:\"We prefer to start with a simple opinionated component and extend it later when a proven need arises.\"}),`\n`,(0,n.jsx)(e.li,{children:`Be opinionated. Is that button always going to say \"Close\"? In that case don't take a prop for it, let the Recipe component own the text.`}),`\n`,(0,n.jsxs)(e.li,{children:[\"Is your component going to come in multiple colors? Don't accept arbitrary values, instead limit it to an opinionated set using semantic property values. For example, a \",(0,n.jsx)(e.code,{children:\"use\"}),\" property that accepts values like \",(0,n.jsx)(e.code,{children:\"info\"}),\", \",(0,n.jsx)(e.code,{children:\"warning\"}),\", \",(0,n.jsx)(e.code,{children:\"error\"}),\" is preferrable to a \",(0,n.jsx)(e.code,{children:\"color\"}),\" property that accepts hex color codes.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h3,{id:\"documentation-first\",children:\"Documentation first\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"We always start by writing the documentation page for the living style guide. Having detailed usage guidelines and a complete API promotes clear systems thinking and is a huge timesaver for preventing churn in the PR.\"}),`\n`,(0,n.jsx)(e.li,{children:\"APIs are hard to take back. Getting to a good API is the most important function of the governance process.\"}),`\n`,(0,n.jsx)(e.li,{children:\"Try to reuse property names across components where appropriate and structure similar properties similarly. For instance, we have a number of components that accept links in a consistent way that supports both URLs and React router.\"}),`\n`,(0,n.jsx)(e.li,{children:\"Good names facilitate communication. Ideally engineers, designers, and end users would all use the same name for your component. When naming a new component it's worth thinking about: common names for that widget in the industry, how different team members refer to it, anything you know about how users refer to it.\"}),`\n`,(0,n.jsx)(e.li,{children:\"Pave the cowpaths. You will have an uphill battle if you pick a name that is different than one teams are already using.\"}),`\n`]}),`\n`,(0,n.jsx)(e.h3,{id:\"keep-evolving\",children:\"Keep evolving\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"Recipe is a living system. The existing components and even the governing principles can change over time.\"}),`\n`,(0,n.jsx)(e.li,{children:\"Think about advocating for change at a system level. Don't think just about making one Table better, think about how you can make all Tables better.\"}),`\n`,(0,n.jsx)(e.li,{children:\"We embrace change, but...\"}),`\n`]}),`\n`,(0,n.jsx)(e.h3,{id:\"be-patient\",children:\"Be patient\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"If you're unsure about whether a pattern will be needed, it's better to wait and monitor whether there is a more widespread need for it.\"}),`\n`,(0,n.jsxs)(e.li,{children:[\"Think about one way doors vs. two way doors. Once downstream applications start using the API, it can be hard to change. However, internal implemenation decisions within Recipe are usually easier to take back and evolve without disrupting client applications. Here are some examples to consider:\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"Adding a new, optional prop can be done with affecting existing client applications.\"}),`\n`,(0,n.jsxs)(e.li,{children:[\"A prop that accepts multiple values makes it easy to extend with additional values in the future. However, you should weigh the likelihood of needing to extend. In some cases a simple boolean flag prop makes for a cleaner API. Take a look at the API for \",(0,n.jsx)(e.a,{href:\"/components/ez-button\",children:\"Button\"}),\" for an example of how a mix of flags and extensible props was carefully chosen.\"]}),`\n`,(0,n.jsx)(e.li,{children:\"Some animations, like rollover states, are easy to add later. However, if you are trying to animate a state change, such as closing a modal, it may require coordinate with the parent application to prevent the component being unmounted before the animation runs. If you think such animations will be important for your component, it was worth considering the API implications during the original design phase.\"}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[\"It's a system\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"Decisions you make about one component can have impacts on the overall cohesion of the system. For example, using color in a new way for your component might make sense in isolation, but you also need to consider whether this creates confusion around the function of existing controls that may use color differently. It may be that your new approach is better overall, in which case you should advocate for evolving the whole family of impacted components.\"}),`\n`,(0,n.jsx)(e.li,{children:\"Systems thinking is hard. If you're passionate about a new concept, keep thinking about how to make it more broadly applicable and integrated into Recipe.\"}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Don't worry about localization (yet)\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"Preparing for localization is explicitly not a 2019 focus for ezCater.\"}),`\n`,(0,n.jsxs)(e.li,{children:[\"It is totally fine and in fact desirable to have English strings within your components. We do encourage however, that these translated strings are isolated from component rendering logic. Recipe internally uses a \",(0,n.jsx)(e.code,{children:\"useTranslation\"}),\" hook to assist with the process of interpolating dynamic values into static messages.\"]}),`\n`,(0,n.jsx)(e.li,{children:\"Eventually we will develop a strategy for initializing Recipe with a locale so that any strings owned by Recipe can be appropriately localized.\"}),`\n`,(0,n.jsx)(e.li,{children:\"Remember that localization is a presentational problem too, so it is definitely within the concern scope for a design system. Think about languages with longer average word length, or even with a different reading order (right to left languages).\"}),`\n`]}),`\n`]}),`\n`]})]});return t?(0,n.jsx)(t,Object.assign({},i,{children:o})):o}var v=w;return k;})();\n;return Component.default;"},"__N_SSG":true}